'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var React = require('react');
var React__default = _interopDefault(React);

function _typeof(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(source, true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(source).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};

  var target = _objectWithoutPropertiesLoose(source, excluded);

  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _possibleConstructorReturn(self, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  }
}

function _iterableToArray(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}

// proptypes
// const providerPropType = PropTypes.shape({
//   Provider: PropTypes.object.isRequired,
//   Consumer: PropTypes.object.isRequired,
// });
// const propTypes = {
//   of: PropTypes.oneOfType([
//     PropTypes.arrayOf(providerPropType),
//     providerPropType
//   ]).isRequired,
//   to: providerPropType,
//   map: PropTypes.func.isRequired,
//   isUnchanged: PropTypes.func,
//   children: PropTypes.node.isRequired
// }

var ContextFilterInner =
/*#__PURE__*/
function (_React$Component) {
  _inherits(ContextFilterInner, _React$Component);

  function ContextFilterInner() {
    _classCallCheck(this, ContextFilterInner);

    return _possibleConstructorReturn(this, _getPrototypeOf(ContextFilterInner).apply(this, arguments));
  }

  _createClass(ContextFilterInner, [{
    key: "shouldComponentUpdate",
    value: function shouldComponentUpdate(nextProps) {
      var touched = nextProps.probe.touched;

      if (!touched) {
        // This is the first time this component updates for
        // the current render cycle of ContextFilterProbe.
        // Since this means that the update is motivated by
        // an update cascade, not a Context update,
        // the component should update in order to propagate
        // the cascade.
        nextProps.probe.touched = true;
        return true;
      }

      var prevValue = this.value;
      var nextValue = nextProps.map.apply(nextProps, _toConsumableArray(nextProps.values));

      var equals = nextProps.isUnchanged || function (a, b) {
        return a === b;
      };

      return nextProps.contextType !== this.props.contextType || !equals(prevValue, nextValue);
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props;

      this.props.probe.touched = true;
      var Context = this.props.contextType;
      this.value = (_this$props = this.props).map.apply(_this$props, _toConsumableArray(this.props.values));
      return React__default.createElement(Context.Provider, {
        value: this.value
      }, this.props.children);
    }
  }]);

  return ContextFilterInner;
}(React__default.Component);

var ContextFilterLayer = function ContextFilterLayer(_ref) {
  var type = _ref.type,
      inner = _ref.inner,
      _ref$values = _ref.values,
      values = _ref$values === void 0 ? [] : _ref$values;
  var context = React.useContext(type);
  return React__default.cloneElement(inner, {
    values: [].concat(_toConsumableArray(values), [context])
  });
};

var ContextFilterProbe = function ContextFilterProbe(_ref2) {
  var ofContext = _ref2.of,
      toContext = _ref2.to,
      map = _ref2.map,
      isUnchanged = _ref2.isUnchanged,
      children = _ref2.children;

  if (!ofContext) {
    throw new Error('ContextFilter requires "of" property');
  }

  if (!toContext && Array.isArray(ofContext)) {
    throw new Error('ContextFilter requires "to" property if "of" property is an Array');
  }

  var probe = {
    touched: false
  };
  var contextTypeArray = Array.isArray(ofContext) ? ofContext : [ofContext];
  var inner = React__default.createElement(ContextFilterInner, {
    contextType: toContext || ofContext,
    values: [],
    isUnchanged: isUnchanged,
    map: map,
    probe: probe
  }, children);
  var element = contextTypeArray.reduceRight(function (memo, type) {
    return React__default.createElement(ContextFilterLayer, {
      type: type,
      inner: memo
    });
  }, inner);
  return element;
};

var ContextFilter = function ContextFilter(props) {
  return React__default.createElement(ContextFilterProbe, props);
}; //ContextFilter.propTypes = propTypes;

var shallowUnchanged = function shallowUnchanged(prev, next) {
  if (prev === next) return true;
  if (!prev || !next) return false;
  var pKey = Object.keys(prev);
  var nKey = Object.keys(next);
  if (pKey.length !== nKey.length) return false;

  for (var i = 0; i < pKey.length; i++) {
    var key = pKey[i];
    if (prev[key] !== next[key] || !nKey.includes(key)) return false;
  }

  return true;
};

var Inner = function Inner(_ref) {
  var $of = _ref.of,
      to = _ref.to,
      propsForComponent = _ref.propsForComponent,
      Component = _ref.Component;
  var context = React.useContext(to || $of);

  if (_typeof(context) !== 'object' || context === null) {
    context = {
      context: context
    };
  }

  return React__default.createElement(Component, _extends({}, context, propsForComponent));
};

var withFilteredContext = function withFilteredContext(props) {
  return function (Component) {
    var OneOffContext = React__default.createContext();

    var HigherOrderComponent = function HigherOrderComponent(propsForComponent) {
      var theProps = typeof props === "function" ? props(propsForComponent) : props;

      var to = theProps.to,
          _map = theProps.map,
          isUnchanged = theProps.isUnchanged,
          rest = _objectWithoutProperties(theProps, ["to", "map", "isUnchanged"]);

      var mappedProps = _objectSpread2({
        to: to || OneOffContext,
        map: function map() {
          var res = _map.apply(void 0, arguments);

          if (_typeof(res) !== "object") {
            throw Error("map function of withFilteredContext must return an object, returned ".concat(_typeof(res)));
          }

          return res || {};
        },
        isUnchanged: isUnchanged || shallowUnchanged
      }, rest);

      return React__default.createElement(ContextFilter, mappedProps, React__default.createElement(Inner, _extends({}, mappedProps, {
        Component: Component,
        propsForComponent: propsForComponent
      })));
    };

    HigherOrderComponent.displayName = Component.displayName || Component.name;
    return HigherOrderComponent;
  };
};

exports.ContextFilter = ContextFilter;
exports.withFilteredContext = withFilteredContext;
